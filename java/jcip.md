

# 第一章 简介

## 并发简史

* 进程：独立的资源，包括内存、文件句柄、安全证书
* 线程：同一个进程内共享资源，包括内存，文件句柄，但每个线程都有各自的程序计数器、栈、局部变量
* 由于同一个进程中的所有线程都将共享进程的内存，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制

## 线程的优势

* 发挥多核处理器能力
* 建模的简单性
* 异步事件的简化过程
* 响应更灵敏的用户界面

## 线程带来的风险

### 安全性
* 读-操作-写（非原子性）
* 多线程中的操作执行顺序是不可预测的
* 多个线程同时访问和修改相同变量时，在串行模型中引入非串行因素

### 活跃性
* 安全性：永远不发生糟糕的事
* 活跃性：某件正确的事情最终会发生，但不够好
	* 串行程序：死循环后的代码不会被执行
	* 并发程序：死锁、饥饿、活锁
### 性能问题
* 调度器临时挂起一个活跃的线程并执行另一线程时，会是线程间上下文切换，当并发量大时，这种频繁切换上下文会带来极大的开销

# 第二章 线程安全性

## 什么是线程安全性

* 当多线程访问某个类时，这个类始终都能表现出正确的行为，这个类就是线程安全的
* 线程安全类中封装了必要的同步机制，客户端无须进一步采取同步措施
* 无状态对象一定是线程安全的（没有局部变量的Servlet）
* 多个线程之间的操作误论采用何种执行时序或交替方式，都要保证不变性条件不被破坏

## 原子性

* 竞态条件：由于不恰当的执行时序而出现不正确的结果，当某个计算的正确性取决于多个线程的交替执行时序时，就发生竞态条件
* 复合操作：先检查后执行、读取修改写入都是符合操作，这些操作必须以原子方式执行以确保线程安全性
* 竞态条件类型：
	* 先检查后执行（Check-Then-Act），基于一种可能失效的观察结果来做出判断或这执行某个计算（延迟初始化）
	* 读取修改写入，基于对象之前的状态定义对象的转换（计数器递增）
	* 不存在则添加（Put-If-Absent）
* 在无状态的类中添加一个状态变量时，如果该状态变量是线程安全的类，这个类仍然是线程安全的

## 加锁机制

* 当不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其它变量的值产生约束，要保持状态的一致性，需要在单个原子操作中更新所有相关的状态变量

### 内置锁

* synchronized
	* 所对象的引用
	* 锁保护的代码块
* 内置锁互斥：当线程A获取线程B持有的锁时，线程A必须等待或阻塞，知道线程B释放这个锁，如果线程B不释放，线程A将永远等待下去
* 任何一个执行同步代码块的线程，都不可能看到有其它线程正在执行由同一个锁保护的同步代码块

### 重入

* 内置锁是可重入的，如果某个线程试图获得一个已经由自己持有的锁，那么这个请求会成功

## 用锁来保护状态

* 锁能使用其保护的代码以串行形式来访问，对共享状态的复合操作，都必须是原子性操作以避免产生竞态条件
* 对于可能被多个线程同时访问的可变状态变量，访问它时都需要持有同一个锁（读取时加锁）
* 每个共享的可变的变量都应该只由一个锁来保护，从而是维护人员知道是哪个锁 
* 获取与对象关联的锁时，并不能阻止其它线程访问该对象，某个线程获得对象的锁之后，只能阻止其它线程获得同一个锁

## 活跃性与性能

* 缩小同步代码块的作用范围，不要将原子操作拆分到多个同步代码块中，尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去
* 当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁

# 第三章 对象共享

## 可见性

* 同步机制不仅保证操作的原子性，还确保多个线程之间对内存写入操作的可见性
* 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整