

# 第一章 简介
## 并发简史
* 进程：独立的资源，包括内存、文件句柄、安全证书
* 线程：同一个进程内共享资源，包括内存，文件句柄，但每个线程都有各自的程序计数器、栈、局部变量
* 由于同一个进程中的所有线程都将共享进程的内存，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制

## 线程的优势
* 发挥多核处理器能力
* 建模的简单性
* 异步事件的简化过程
* 响应更灵敏的用户界面

## 线程带来的风险

### 安全性
* 读-操作-写（非原子性）
* 多线程中的操作执行顺序是不可预测的
* 多个线程同时访问和修改相同变量时，在串行模型中引入非串行因素

### 活跃性
* 安全性：永远不发生糟糕的事
* 活跃性：某件正确的事情最终会发生，但不够好
	* 串行程序：死循环后的代码不会被执行
	* 并发程序：死锁、饥饿、活锁

### 性能问题
* 调度器临时挂起一个活跃的线程并执行另一线程时，会是线程间上下文切换，当并发量大时，这种频繁切换上下文会带来极大的开销

# 第二章 线程安全性
## 什么是线程安全性
* 当多线程访问某个类时，这个类始终都能表现出正确的行为，这个类就是线程安全的
* 线程安全类中封装了必要的同步机制，客户端无须进一步采取同步措施
* 无状态对象一定是线程安全的（没有局部变量的Servlet）
* 多个线程之间的操作误论采用何种执行时序或交替方式，都要保证不变性条件不被破坏

## 原子性
* 竞态条件：由于不恰当的执行时序而出现不正确的结果，当某个计算的正确性取决于多个线程的交替执行时序时，就发生竞态条件
* 复合操作：先检查后执行、读取修改写入都是符合操作，这些操作必须以原子方式执行以确保线程安全性
* 竞态条件类型：
	* 先检查后执行（Check-Then-Act），基于一种可能失效的观察结果来做出判断或这执行某个计算（延迟初始化）
	* 读取修改写入，基于对象之前的状态定义对象的转换（计数器递增）
	* 不存在则添加（Put-If-Absent）
* 在无状态的类中添加一个状态变量时，如果该状态变量是线程安全的类，这个类仍然是线程安全的

## 加锁机制
* 当不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其它变量的值产生约束，要保持状态的一致性，需要在单个原子操作中更新所有相关的状态变量

### 内置锁
* synchronized
	* 所对象的引用
	* 锁保护的代码块
* 内置锁互斥：当线程A获取线程B持有的锁时，线程A必须等待或阻塞，知道线程B释放这个锁，如果线程B不释放，线程A将永远等待下去
* 任何一个执行同步代码块的线程，都不可能看到有其它线程正在执行由同一个锁保护的同步代码块

### 重入
* 内置锁是可重入的，如果某个线程试图获得一个已经由自己持有的锁，那么这个请求会成功

## 用锁来保护状态
* 锁能使用其保护的代码以串行形式来访问，对共享状态的复合操作，都必须是原子性操作以避免产生竞态条件
* 对于可能被多个线程同时访问的可变状态变量，访问它时都需要持有同一个锁（读取时加锁）
* 每个共享的可变的变量都应该只由一个锁来保护，从而是维护人员知道是哪个锁 
* 获取与对象关联的锁时，并不能阻止其它线程访问该对象，某个线程获得对象的锁之后，只能阻止其它线程获得同一个锁

## 活跃性与性能
* 缩小同步代码块的作用范围，不要将原子操作拆分到多个同步代码块中，尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去
* 当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁

# 第三章 对象共享
## 可见性
* 同步机制不仅保证操作的原子性，还确保多个线程之间对内存写入操作的可见性
* 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整

### 失效数据
* 对于共享数据的get/set时，一定要是原子性
* 线程间操作共享数据时，一定要保证可见性

### 非原子的64位操作
* 最低安全性：在没有同步下读取变量时，可能得到一个失效的值，但至少这个值是由之前某个线程设置的值，而不是随机的值
* Java内存模型要求变量的读操作、写操作必须是原子性的，但对于非volatile的long、double变量，JVM允许将64位的读/写操作分解为两个32为操作

### 加锁与可见性
* 访问某个共享变量时要求所有线程在同一个锁上同步，为了确保某个线程写入该变量的值对于其它线程来说都是可见的
* 加锁的含义不仅局限于互斥，还包括内存可见性

### volatile变量
* 弱同步机制，比synchronized轻量级，确保变量的更新操作通知其它线程
* 当变量声明为volatile后，编译器与运行时都不会将该变量上的操作与其它内存操作一起重排，也不会被缓存在寄存器或对其它处理器不可见的地方，读取volatile变量时总是返回最新写入的值
* 不建议过度依赖volatile变量的可见性，这种可见性比锁更脆弱，更难以理解
* volatile变量通常做某个操作完成、发生中断、状态标志
* 加锁机制既可以保证可见性又可以保证原子性，volatile变量只能确保可见性

## 发布与溢出
* 发布，一个对象能够在当前作用域之外的代码中使用
* 逸出，当某个不应该发布的对象被发布时
* 变量发布：static变量、getter方法、public变量、内部类

## 线程封闭
* 线程封闭，在单线程内访问数据，即某个对象封闭在一个线程中，即使被封闭的对象不是线程安全的，也不需要同步
* 线程封闭是在程序设计中的一个考虑因素，必须在程序中实现，确保封闭在线程中的对象不会从线程中逸出

### ad-hoc线程封闭
* 指维护线程封闭性的职责完全由程序实现来承担
* 单线程提供的简单性要胜过ad-hoc线程封闭技术的脆弱性
* volatile线程封闭性，只要能确保单线程对共享volatile变量执行写入操作，就可以安全的在这个共享的volatile变量上执行“读-改-写”操作，并且还能确保volatile变量对其它线程的可见性

### 栈封闭
* 指只能通过局部变量才能访问对象，局部变量固有的属性之一就是封闭在执行的线程中，它们位于执行线程的栈中，其它线程无法访问
* 对象的逸出会破坏线程封闭性

### ThreadLocal类

## 不变性
* 某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象
* 不可变对象一定是线程安全的，Java语言规范和JVM内存模型都没有给出不可变性的正式定义
* 对象不可变
	* 对象创建以后其状态不能修改
	* 对象所有域都是final类型
	* 对象创建期间，this引用没有逸出

### Fianl域

###　使用volatile类型发布不可变对象
* 通过使用包含多个状态变量的容器对象来维持不变性条件，并使用volatile类型的引用确保可见性，在没有显示锁的情况下也可保证线程安全

## 安全发布
* 如果没有足够的同步，当多线程共享数据时将发生一些非常奇怪的事情
* 多线程实例化一个对象
	* 当前线程实例化了对象，其它线程却看不到
	* 当前线程修改了对象，其它线程看到的是一个失效的值
* 可变对象的发布和使用都必须使用同步，要安全的发布一个对象，对象的引用及对象的状态必须同时对其它线程可见
* 安全发布对象的模式
	* 将对象放入线程安全的容器（Vector、Hashtable、CopyOnWriteArrayList、BlockingQueue）
	* 静态初始化器由JVM在类的初始化阶段执行，在JVM内部存在着同步机制
* 可变对象不仅在发布时需要使用同步，在每次对象访问时同样需要使用同步来确保后续修改操作的可见性

# 第四章 对象的组合


