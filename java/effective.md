
## 第四章 类和接口

### Iitem13：使类和成员的可访问性最小化

* 设计良好的模块可以对外部其它模块隐藏内部数据和实现细节，把API与实现清晰隔离开，这也是面向对象封装性的体现

* 尽可能地使每个类或者成员不被外加访问（最小访问级别）

* 访问权限
	* private：当前类内部
	* default：包内任何类，默认权限
	* protected：包内任何类，子类
	* public：任何地方都可以访问

* 实现Serializable接口的类可能会被泄漏出定义的API

* 子类覆盖父类中的方法，子类中方法的访问级别不允许低于父类中的访问级别，接口中的所有方法都是public

* public fianl、final引用可变对象，都将放弃对字段的访问限制功能，public static final定于的全局常量在系统中被引用，这是例外情况

* 长度非0的数组总是可变的，类中具有public static fianl的数组，或存在这种数组的getter方法，这几乎总是错误的行为

* 解决publi static fianl 可安全访问的两种方法

		# public数组变private数组，增加一个public的不可变List
		private static final String[] PRIVATE_VALUES = { "A", "B", "C" };
		public static final List<String> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

		# public数组变private数组，返回私有数组的备份
		private static final String[] PRIVATE_VALUES = { "A", "B", "C" };
		public static final String[] values(){
			return PRIVATE_VALUES.clone();
		}

### Item14：在公有类中使用访问方法而非共有域

* 面向对象程序设计中，类应该包含私有字段，公共有访问方法（getter），对于可变的字段，应该包含私有字段和射值方法（setter）

* 如果类可以在它所在的包的外部进行访问，就应该提供访问方法 

### Item15：使可变性最小化

* 不可变类是实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变（String、基本类型包装类、BigInteger）

* 类不可变5原则
	1. 不提供任何会修改对象状态的方法
	2. 保证类不会被扩展（final class、private构造器）
	3. 使类中所有字段都是final的（清晰的表明意图）
	4. 使类中所有字段都是private的（防止客户端直接修改字段）
	5. 确保对于任何可变组件的互斥访问（类中包含一个可变对象字段，确保客户端不能直接修改这个对象）

* 不可变对象本质上线程安全的，它们不要求同步，不可变对象可以被自由的共享

* 不可变对象不需要保护性拷贝，也不应该有clone方法（String却有clone方法）

* 不可变类可以使用静态工厂获得，考虑使用静态工厂替代公有构造器

* 不可变类唯一的缺点是，对于每个不同的值都需要一个单独的对象，创建对象的代价可能很高

* 坚决不要为每个getter()编写一个setter()，除非有很好的理由

* 如果类不能被做成不可变的，仍然应该进可能的限制它的可变性，降低对象可以存在的状态数

* 类中的每个字段都应尽可能的是final的

* 不要在构造器或静态工厂之外的地方在提供公有的初始化方法，也不应该提供重新初始化的方法

### Item16：复合先于继承

* 继承是实现代码重用一种方法，在包内的继承非常安全，跨越包边界的继承非常危险

* 继承打破了封装性，子类依赖于超类中的特定实现细节，超类发生改变，子类可能遭到破坏（继承HashSet统计元素个数）

* 如果父类在新版本中增加了一个新的方法，该方法与子类拥有完全相同的方法签名和返回类型，子类将overriding超类中的方法

* 如果父类在新版本中增加了一个新的方法，该方法与子类拥有完全相同的方法签名和不同的返回类型，编译将无法通过

* 不使用继承，而使用组合，在新类中包含一个私有字段，引用现有类的一个实例，新类中的每个方法都可以调用私有字段实例的方法，并返回结果

* 继承一个类时，思考父类API有没有缺陷，缺陷会传播到子类的API中，组合可以隐藏API的缺陷
 
* 只有当子类真正是超类的子类型时，才适合用继承，A和B确定两者是“is-a”关系时，B才应该扩展A（B is a A）

### Item17：要么为继承而设计，并提供文档说明，要么就禁止继承

* 好的API文档应该描述一个给定的方法做了什么工作，而不是描述他如何做到的

* 为了继承而设计的类，唯一的测试方法就是编写子类，3个子类通常足以测试一个可扩展的类

* 可继承类中构造器绝不能调用可被覆盖的方法，无论是直接还是间接

* 如果类被设计为可继承的，实现Cloneable、Serializable接口都不是好主意

### Item18：接口优于抽象类

* 现有的类可以很容易被更新，以实现新的接口，但无法通过更新现有类来扩展新的抽象类

* 接口允许构造非层次结构的类型框架，继承会导致层次结构臃肿

		class A{}
		calss B extends A{}
		class C extends B{}
		
		interface A{}
		interface B{}
		interface C extends A,B{}

* 对每个接口提供一个抽象类实现，把抽象类和接口的优点结合，接口仍然定义类型，但抽象类接管了所有与接口实现相关的工作（Collections Framework 为每个重要的接口提供了一个AbstractInterface实现）